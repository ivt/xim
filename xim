#!/usr/bin/perl
use Switch;
use strict;
use warnings;

# Set this to 1 to fake external command execution
our $dryrun = 1;
our $debug  = 1;
our $silent = 1;

####################################################################
# xim: Xen Image Manager
#
# Creates the disk image and configuration for a new Xen virtual machine
#
# @version 0.1 20060803
# @version 0.2 20060905
# @author Jonathan Oxer <jon@ivt.com.au>
# @copyright 2006 Internet Vision Technologies <www.ivt.com.au>
####################################################################
# Figure out what command we've been called with. Initially, many of
# the commands will just be wrappers to xm and will pass arguments
# through unchanged.
if($ARGV[0])
{
	switch ($ARGV[0])
	{
		case "console"   { xm_wrapper() }
		case "create"    { xm_wrapper() }
		case "destroy"   { xm_wrapper() }
		case "list"      { xm_wrapper() }
		case "mem-set"   { xm_wrapper() }
		case "migrate"   { xm_wrapper() }
		case "pause"     { xm_wrapper() }
		case "reboot"    { xm_wrapper() }
		case "restore"   { xm_wrapper() }
		case "save"      { xm_wrapper() }
		case "shutdown"  { xm_wrapper() }
		case "top"       { xm_wrapper() }
		case "unpause"   { xm_wrapper() }
		case "vcpu-set"  { xm_wrapper() }

		case "build"     { build() }
		case "demolish"  { demolish() }
		case "relocate"  { relocate() }
		case "propagate" { propagate() }

		else             { usage(); exit }
	}
	exit;
}
else
{
	usage();
	exit;
}


####################################################################
# Wrap subcommands and pass them off to XM
sub xm_wrapper {
	# Glob all the command line arguments together for XM
	my $arguments;
	foreach (@ARGV) {
		$arguments .= " " . $_;
	}
	my $command = "xm" . $arguments;
#	print "$command\n";
	`$command`;
}


####################################################################
# Display internal usage info. Note that failed subcommands
# passed through to XM will result in XM's internal help being
# returned instead.
sub usage {
	print "Sorry, you need to specify a subcommand. Xim supports\n";
	print "the following standard xm subcommands:\n";
	print "   console\n";
	print "   create\n";
	print "   destroy\n";
	print "   list\n";
	print "   mem-set\n";
	print "   migrate\n";
	print "   pause\n";
	print "   reboot\n";
	print "   restore\n";
	print "   save\n";
	print "   shutdown\n";
	print "   top\n";
	print "   unpause\n";
	print "   vcpu-set\n";
	print "Xim also supports these extended subcommands:\n";
	print "   build <DomGroup> <DomName>              Create a new VM image and config\n";
	print "   demolish <DomGroup> <DomName>           Destroy a VM and delete all its files\n";
	print "   relocate <DomGroup> <DomName> <Host>    Migrate a running VM to another node\n";
	print "   propagate <DomGroup> <DomName> <Host>   Make a backup of a VM on another node\n";
	print "<DomGroup> is a way to arbitrarily group guest domains: each DomGroup is given\n";
	print "its own Volume Group in LVM and managed at a separate mount point.\n";
}


####################################################################
# Prompt the user for input and return the result or a default
sub prompt {
	my ($promptstring, $defaultvalue) = @_;
	if ($defaultvalue) {
		print $promptstring . "[" . $defaultvalue . "]";
	} else {
		print $promptstring . ": ";
	}
	$| = 1;
	$_ = <STDIN>;
	chomp;

	if ($defaultvalue) {
		return $_ ? $_ : $defaultvalue;
	} else {
		return $_;
	}
}



####################################################################
# Execute commands only if we're not in dry-run mode.
sub runcommand {
	my ($command, $output) = @_;
	my $result = "";

	# Display some text to the user
	if (($output) && ($silent ne 1)) {
		print " * " . $output . "\n";
	}

	# Print debug output
	if ($debug eq 1) {
		print "$command\n";
	}

	# Execute the requested command
	if ($dryrun ne 1) {
		$result = `$command`;
	}
	return ($result);
}

sub runcommand2 {
	my ($command, $output) = @_;
	my $result = "";

	# Display some text to the user
	if (($output) && ($silent ne 1)) {
		print " * " . $output . "\n";
	}

	# Print debug output
	if ($debug eq 1) {
		print "$command\n";
	}

	# Execute the requested command
	if ($dryrun ne 2) {
		$result = `$command`;
	}
	chomp($result);
	return ($result);
}


####################################################################
# Build a brand new VM
sub build {
	# Check if we have enough arguments
	if ( ($#ARGV + 1) eq 3 )
	{
#		print "Let's make a new VM!\n";
		my $imagegroup = $ARGV[1];
		my $imagename  = $ARGV[2];
		my $storagepath = "/" . $imagegroup;
#		print "$imagegroup\n";
#		print "$imagename\n";
#		print "$storagepath\n";
		# Prompt for user input for a bunch of settings for this VM
		my $vm_disksize  = prompt ("Size of disk image in GB:", "5");
		my $vm_swapsize  = prompt ("Size of swap space in MB:", "200");
		my $vm_ram       = prompt ("Size of RAM allocation in MB:", "192");
		my $vm_ipaddress = prompt ("IP address:", "221.133.213.254");
		my $vm_netmask   = prompt ("Netmask:", "255.255.255.0");
		my $vm_gateway   = prompt ("Gateway:", "221.133.213.1");
		my $vm_resolver  = prompt ("DNS server:", "202.91.207.135");

		# Figure out the MAC address based on the IP
		# Split the dotted quads into array elements
		our @vm_mac = split(/\./, $vm_ipaddress);
		# Make sure each element is padded to three digits so we have a 12-digit number
		$vm_mac[0] = sprintf"%03d",$vm_mac[0];
		$vm_mac[1] = sprintf"%03d",$vm_mac[1];
		$vm_mac[2] = sprintf"%03d",$vm_mac[2];
		$vm_mac[3] = sprintf"%03d",$vm_mac[3];
		# Put the elements back together as one long string
		$main::vm_mac = join("", @vm_mac);
		# Chunk split the string into colon separated pairs of digits
		$main::vm_mac = substr($main::vm_mac, 0, 2).":".substr($main::vm_mac, 2, 2).":".substr($main::vm_mac, 4, 2).":".substr($main::vm_mac, 6, 2).":".substr($main::vm_mac, 8, 2).":".substr($main::vm_mac, 10, 2);

		# Show what values we're going to use
		print "Values for the new VM will be:\n";
		print " Name:       $imagename\n";
		print " Disk Size:  $vm_disksize GB\n";
		print " Swap Size:  $vm_swapsize MB\n";
		print " RAM Size:   $vm_ram MB\n";
		print " IP Address: $vm_ipaddress\n";
		print " Netmask:    $vm_netmask\n";
		print " Gateway:    $vm_gateway\n";
		print " DNS server: $vm_resolver\n";
		print " MAC addr:   $main::vm_mac\n";

		# Give one last chance to bail out before we start changing things
		my $continue  = prompt ("Continue?:", "Y");
		$continue =~ tr/A-Z/a-z/;
		if($continue ne "y")
		{
			print "OK, bailing out\n";
			exit 0;
		}

		# Execute the commands to create the VM image
		my $command = "";

		$command = "mkdir -p $storagepath/$imagename.d/mnt";
		runcommand ("$command", "Creating VM directory and mount point...");

		my $vm_disksizemb = $vm_disksize * 1000;
		$command = "lvcreate -L${vm_disksizemb}M -n ${imagename}-root $imagegroup";
		runcommand ("$command", "Creating the target root partition...");

		$command = "mkfs.ext3 /dev/mapper/${imagegroup}-${imagename}--root";
		runcommand ("$command", "Creating root filesystem on target root partition...");

		$command = "mount /dev/$imagegroup/${imagename}-root $storagepath/$imagename.d/mnt/";
		runcommand ("$command", "Mounting target root partition...");

		$command = "mount /dev/$imagegroup/guest $storagepath/guest/";
		runcommand ("$command", "Mounting source filesystem...");

		$command = "cp -a $storagepath/guest/* $storagepath/$imagename.d/mnt/";
		runcommand ("$command", "Copying source filesystem to target filesystem...");

		$command = "lvcreate -L{$vm_swapsize}M -n ${imagename}-swap $imagegroup";
		runcommand ("$command", "Creating the swap partition...");

		$command = "mkswap /dev/$imagegroup/${imagename}-swap";
		runcommand ("$command", "Creating swap filesystem...");

		# Create Xen conf
		print "Creating Xen config file...";
		my $vm_xenconfig = "#  -*- mode: python; -*-
kernel = \"/boot/vmlinuz-2.6.16-xen\"
ramdisk = \"/boot/initrd-2.6.16-xen.img\"
memory = $vm_ram
name = \"$imagename\"
vif = ['mac=$main::vm_mac,bridge=xenbr0']
disk = ['phy:$imagegroup/${imagename}-root,hda1,w','phy:$imagegroup/${imagename}-swap,hda2,w']
ip = \"$vm_ipaddress\"
netmask = \"$vm_netmask\"
gateway = \"$vm_gateway\"
hostname = \"$imagename\"
root = \"/dev/hda1 ro\"
extra = \"4\"";
		if($dryrun ne 1) {
			open (CONFIGFILE, ">$storagepath/$imagename.d/$imagename");
			print CONFIGFILE $vm_xenconfig;
			close (CONFIGFILE);
		}
		print "done\n";

		# Create interfaces
		print "Creating /etc/network/interfaces...";
		my $vm_netconfig = "# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto eth0
iface eth0 inet static
		address $vm_ipaddress
		netmask $vm_netmask
		gateway $vm_gateway
#        broadcast 1.0.1.255
#        dns-nameservers 192.168.0.1";
		if($dryrun ne 1) {
			open (CONFIGFILE, ">$storagepath/$imagename.d/mnt/etc/network/interfaces");
			print CONFIGFILE $vm_netconfig;
			close (CONFIGFILE);
		}
		print "done\n";

		# Create hostname
		print "Creating /etc/hostname...";
		my $vm_hostnameconfig = "$imagename";
		if($dryrun ne 1) {
			open (CONFIGFILE, ">$storagepath/$imagename.d/mnt/etc/hostname");
			print CONFIGFILE $vm_hostnameconfig;
			close (CONFIGFILE);
		}
		print "done\n";

		# Create hosts
		print "Creating /etc/hosts...";
		my $vm_hostsconfig = "127.0.0.1       localhost localhost.localdomain
127.0.0.1       $imagename
221.133.213.9	cache

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
ff02::3 ip6-allhosts";
		if($dryrun ne 1) {
			open (CONFIGFILE, ">$storagepath/$imagename.d/mnt/etc/hosts");
			print CONFIGFILE $vm_hostsconfig;
			close (CONFIGFILE);
		}
		print "done\n";

		# Create symlink for Xen
		#print "Creating config symlink...";
		#my $command = "ln -s /xen-images/$imagename/$imagename /etc/xen/$imagename";
		#print "c: $command\n";
		#`$command`;
		#print "done\n";

		# Unmount source and target
		$command = "sync; umount $storagepath/$imagename.d/mnt; umount $storagepath/guest";
		runcommand ("$command", "Unmounting source and target filesystems...");

	} else {
		print "Usage: xim build <imagegroup> <imagename>\n";
	}
}


####################################################################
# Demolish an existing VM
sub demolish {
	# Check if we have enough arguments
	if ( ( ($#ARGV + 1) eq 3 ) or ( ($#ARGV + 1) eq 4) )
	{
		my $imagegroup = $ARGV[1];
		my $imagename  = $ARGV[2];
		my $storagepath = "/" . $imagegroup;

		# Set the default node to localhost but allow the third argument to override it
		my $node = "localhost";
		if ( ($#ARGV + 1) eq 4 )
		{
			$node  = $ARGV[3];
		}

		print "Demolishing '${imagegroup}/${imagename}' on '${node}'\n";

		my $command = "";

		# Destroy the image in case it's running. Since we're nuking it anyway we
		# don't need to bring it down cleanly or wait politely
		$command = "xm destroy $imagename";
		runcommand ("$command", "Destroying image...");

		# lvremove root
		$command = "lvremove /dev/${imagegroup}/${imagename}-root";
		runcommand ("$command", "Removing root partition...");

		# Remove swap
		$command = "lvremove /dev/${imagegroup}/${imagename}-swap";
		runcommand ("$command", "Removing swap partition...");

		# Remove the config directory
		$command = "rm -Rf /${imagegroup}/${imagename}.d";
		runcommand ("$command", "Removing config directory...");
	} else {
		print "Usage: xim demolish <imagegroup> <imagename> [Host]\n";
		print "   'demolish' will remove all traces of a VM from a specific node, or from\n";
		print "   localhost if no host is specified: it destroys the running image if it\n";
		print "   exists, then removes the config directory and partitions.\n";
	}
}


####################################################################
# Snapshot an existing VM to push it out to another node
sub relocate {
	print "Relocating an existing VM to another node\n";
}


####################################################################
# Snapshot an existing VM to push it out to another node
sub propagate {
	# Check if we have enough arguments
	if ( ($#ARGV + 1) eq 4 )
	{
		my $imagegroup = $ARGV[1];
		my $imagename  = $ARGV[2];
		my $node       = $ARGV[3];
		my $storagepath = "/".${imagegroup};
		print "Propagating '${imagegroup}/${imagename}' to '${node}'\n";
		# lvcreate -L500M -s -n imagename-snapshot /dev/imagegroup/imagename-root

		my $command = "";

		$command = "modprobe dm-snapshot";
		runcommand ("$command", "Loading snapshot device-mapper kernel module...");

		$command = "mkdir -p $storagepath/$imagename.d/snapshot";
		runcommand ("$command", "Creating backup mount point...");

		# We're hard-coding a disk image size here, which is bad. Need to check size of local partition
		#my $vm_disksize = `lvdisplay /dev/${imagegroup}/${imagename}-root | grep "LV Size" | awk '\{print \$3\}'`;
		my $vm_disksize = 25;
		my $vm_disksizemb = $vm_disksize * 1000;
		$command = "lvcreate -L${vm_disksizemb}M -s -n ${imagename}-snapshot /dev/$imagegroup/${imagename}-root";
		$command = "lvcreate -L2000M -s -n \"${imagename}-snapshot\" /dev/$imagegroup/${imagename}-root";
		runcommand ("$command", "Creating the snapshot partition...");

		$command = "mount /dev/mapper/${imagegroup}-${imagename}--snapshot $storagepath/$imagename.d/snapshot/";
		runcommand ("$command", "Mounting snapshot...");
#www.arsgeek.com/?p=650
		
		$command = "ssh root\@${node} mkdir -p ${storagepath}/${imagename}.d/mnt";
		runcommand ("$command", "Making VM directory and mount point on target node...");

		my $partitionexists = 0;
		$command = "ssh root\@${node} lvscan | grep ${imagename}-root | wc -l";
		$partitionexists = runcommand ("$command", "Checking for VM root partition on target node...");
		print "e: $partitionexists\n";

		if ($partitionexists eq 0) {
			$command = "ssh root\@${node} lvcreate -L${vm_disksizemb}M -n \"${imagename}-root\" ${imagegroup}";
			runcommand ("$command", "Creating VM root partition on target node...");

			$command = "ssh root\@${node} mkfs.ext3 /dev/mapper/${imagegroup}-${imagename}--root";
			runcommand ("$command", "Creating VM root filesystem on target node...");
		}

		$command = "ssh root\@${node} mount /dev/mapper/${imagegroup}-${imagename}--root ${storagepath}/${imagename}.d/mnt";
		runcommand ("$command", "Mounting VM root on target node...");

		$command = "rsync -e ssh --delete -az $storagepath/${imagename}.d/snapshot/ root\@${node}:${storagepath}/${imagename}.d/mnt";
		runcommand ("$command", "Pushing root filesystem to target node...");

		$command = "scp $storagepath/${imagename}.d/${imagename} root\@${node}:${storagepath}/${imagename}.d/";
		runcommand ("$command", "Copying config file to target node...");

		$command = "sync; umount ${storagepath}/${imagename}.d/snapshot";
		runcommand ("$command", "Unmounting VM snapshot...");

		$command = "lvremove -f /dev/${imagegroup}/${imagename}-snapshot";
		runcommand ("$command", "Removing snapshot partition...");

		$command = "ssh root\@${node} \"umount ${storagepath}/${imagename}.d/mnt\"";
		runcommand ("$command", "Unmounting root filesystem on target node...");

#		$command = "";
#		runcommand ("$command", "...");

	} else {
		print "Usage: xim propagate <imagegroup> <imagename> [Host]\n";
		print "   'propagate' copies the config and partitions of a VM to another\n";
		print "   node. If a copy already exists on the remote node it's updated.\n";
	}
}



